* archive [43/43]
** DONE Error reporting from parsers                                :parsing:
   CLOSED: [2013-09-21 Sat 22:46]
   There should be an easy way to report parse errors, and they should be helpful.
** DONE Improve the run() interface                                     :API:
   CLOSED: [2013-09-21 Sat 22:46]
   It kinda sucks that you get this weird object that you have to grab .val
   from, and that you can't get all the results in an ambiguous parse from
   it. There's also no real point in exposing input to the outside, I don't
   think.
** DONE Port all the old parsers over to new API                    :parsing:
   CLOSED: [2013-09-22 Sun 01:20]
** DONE Document API                                                    :doc:
   CLOSED: [2013-09-22 Sun 13:39]
** DONE Fix the stupid parserFoo naming scheme                          :API:
   CLOSED: [2013-09-22 Sun 13:39]
** DONE Unit tests for all parsers                                     :test:
   CLOSED: [2013-09-22 Sun 14:19]
** DONE Write a more helpful README.md                                 :meta:
   CLOSED: [2013-09-22 Sun 15:52]
** DONE Set up testling and travis                                     :meta:
   CLOSED: [2013-09-22 Sun 15:53]
** DONE Make sure docs properly end up in docjs docs                    :doc:
   CLOSED: [2013-09-22 Sun 15:53]
** DONE Publish to NPM and Bower                                       :meta:
   CLOSED: [2013-09-22 Sun 20:34]
** DONE Write an 'expected' parser that spits out useful messages   :parsing:
   CLOSED: [2013-09-22 Sun 20:37]
** DONE Update examples/date.js                                    :examples:
   CLOSED: [2013-09-22 Sun 21:27]
** DONE Bring over all the important functions from Parsec          :parsing:
   CLOSED: [2013-09-23 Mon 00:59]
   Write mona equivalents for all the stuff that matters from Prim, Combinator,
   and Char. Not sure if I care enough to port over Perm. Maybe add a separate
   todo for that.

   I don't think any others are terribly critical right now. Bring them over
   piecemeal as more parsers get written.
** DONE Figure out stack blowout for sexp                               :bug:
   CLOSED: [2013-09-23 Mon 09:42]
   Problem solved... the way mona works with all the function definitions means
   that recursive parsers will blow the hell up. This also exposes the issue
   that we're creating way too many parsers and crapping up memory when we could
   probably completely avoid that if we handle these functions differently.
** DONE Figure out how to change the API to fix overflows               :API:
   CLOSED: [2013-09-23 Mon 10:17]
** DONE Write test for mona.delay()                                    :test:
   CLOSED: [2013-09-23 Mon 13:19]
   Commit delay when done.
** DONE case-sensitivity control                                        :API:
   CLOSED: [2013-09-23 Mon 18:55]
   Should be something available to all/most string-related parsers, I think?
** DONE Use .charAt instead of [x]                                    :input:
   CLOSED: [2013-09-23 Mon 18:56]
   Apparently, array-like access is a feature of ES5. Oops!
** DONE Print errors properly in node                                   :API:
   CLOSED: [2013-09-23 Mon 21:15]
   For some reason, node just says Error when a parser error is thrown, even
   though it has a 'message' field, a name, and it inherits from Error. I'm not
   sure what else needs to be done!
** DONE Host the docs for releases on a github page.                   :docs:
   CLOSED: [2013-09-23 Mon 21:41]
** DONE Streaming support                                           :parsing:
   CLOSED: [2013-09-24 Tue 10:21]
   Support fast, buffered streamed parsing. Try and support at least node's
   async API, but see if promises can also be supported.

   Because of the way parsing works (potentially backtracking by a lot), it
   might be wise to make the streaming system support dividing the parse into
   separate chunks, with a callback to execute for each successful chunk
   received from the stream. The chunking parser would still keep track of the
   position in the stream and report it properly during errors.

   For example:
   var parser = parseAsync(csvLine(), function(err, line) {
     if (err) { console.error(err); } else { console.log("Got a csv line: ", line); }
   });
   var stream = fs.createReadStream(filename);
   stream.on("data", parser.data);
   stream.on("error", parser.error);
   stream.on("end", parser.done);

** DONE parseAsync handles should return the handle                     :API:
   CLOSED: [2013-09-24 Tue 18:10]
   Would make it nicer for chaining, and there's nothing else worth returning
   from these 'methods'.
** DONE Fix remaining tests                                           :tests:
   CLOSED: [2013-09-24 Tue 21:19]
** DONE Get rid of attr()                                          :internal:
   CLOSED: [2013-09-24 Tue 21:25]
   Just copy() the objects and side-effect them to reduce consing.
** DONE Fix whatever is causing source positions to be wrong.        :errors:
   CLOSED: [2013-09-24 Tue 21:25]
** DONE Better error messages                                        :errors:
   CLOSED: [2013-09-24 Tue 21:27]
   Look more into how error messages get collected and combined.
** DONE Improve sequence error reporting                                :API:
   CLOSED: [2013-09-24 Tue 21:32]
   "whatever isn't a function. ohnoes!"
** DONE Use an offset index instead of consing new strings            :input:
   CLOSED: [2013-09-24 Tue 22:11]
** DONE Properly support node's stream API                              :API:
   CLOSED: [2013-09-25 Wed 01:22]
   http://nodejs.org/api/stream.html#stream_class_stream_transform_1
** DONE wrap() parser                                                   :API:
   CLOSED: [2013-09-25 Wed 08:56]
   Returns a tagged version of a parser's results, so: wrap(token(), "letter")
   would result in {letter:"a"} or something of the sort. Useful when you have
   an existing parser and just want to label what you got for something else to
   consume.
** DONE map() parser                                                    :API:
   CLOSED: [2013-09-25 Wed 08:56]
   A generalized version of wrap() that calls a function on the resulting value
   of a parser. This is similar to bind(), except it's expected to return a
   value, not another parser.
** DONE Improve/fix CSV example                                    :examples:
   CLOSED: [2013-09-25 Wed 22:50]
** DONE Include a version in the 'mona' object                          :API:
   CLOSED: [2013-09-25 Wed 23:01]
   And modify make release to automatically update it.
** DONE float() parser                                                  :API:
   CLOSED: [2013-09-26 Thu 23:07]
   Needs tests
** DONE Swap argument order for map()                                   :API:
   CLOSED: [2013-09-26 Thu 23:08]
   the current version kinda sucks for indentation.
** DONE Consider a whitespace-trimming utility                          :API:
   CLOSED: [2013-09-26 Thu 23:54]
   and(maybe(spaces()), something(), maybe(spaces())) is pretty common...
** DONE JSON parser                                                :examples:
   CLOSED: [2013-09-27 Fri 00:06]
   Write a unit test for it, too, eventually.
   
   Right now, just needs some cleanup, unicodeHex(), and pulling out
   trim() into mona.
** DONE tests for trim() and family                                   :tests:
   CLOSED: [2013-09-27 Fri 00:22]
** DONE tests for collect() and exactly()                             :tests:
   CLOSED: [2013-09-27 Fri 00:29]
** DONE Consider getting rid of zeroOrMore and oneOrMore                :API:
   CLOSED: [2013-09-27 Fri 00:38]
   They're trivial with collect(), so maybe they're just redundant.
** DONE times() parser                                                  :API:
   CLOSED: [2013-09-27 Fri 00:39]
   Applies a parser exactly N times and returns the results in an array.
   NOTE: created as exactly()
** DONE Consider getting rid of character()                             :API:
   CLOSED: [2013-09-27 Fri 00:57]
   It doesn't make much of a difference in JS, since they're strings
   anyway, and any performance-oriented special cases can be done right in
   string(). Can we just use that? This would involve touching a lot of
   code and be fairly API-breaking, so it would be good to do it sooner
   rather than later.
** DONE digitCharacter() and digit()                                    :API:
   CLOSED: [2013-09-27 Fri 01:00]
   digitCharacter() kinda sucks. Maybe this should just be done as part of
   splitting mona up into multiple modules to disambiguate digit() and
   digitCharacater()? Is numeric() enough to mean "this will return a
   string, use digit() for numbers? Should digit() go away entirely as a
   numeric function and be strictly for strings? Why would you ever want to
   parse a single digit as an integer without processing it as a string,
   first? (if an integer() parser already exists)
* backlog [0/15]
** TODO breakpoint() combinator                                         :API:
   Insert a debugger; statement before and after a parser is executed. Give a
   choice as to whether to break before, after, or both?
** TODO Write a CL-style extensible reader example                 :examples:
** TODO Write some tutorials                                           :docs:
** TODO Write cardinal and ordinal number parsers                       :API:
   Including the english counterparts:
   ordinals: 1st, 2nd, third, fourth...
   cardinals: 1, 2, three, four...
** TODO Split mona up into multiple modules                             :API:
   Could still export all of mona from just the mona module, but it might be
   nicer for documentation and code organization if there's topic-based modules.
** TODO Support userState                                               :API:
** TODO Make a note in the docs about recursive parsers                :docs:
   Instruct people to use either sequence or delay, or some similar
   construct. Might be good to just put this in a tutorial.
** TODO Bring back nondeterministic parsing                         :parsing:
** TODO Add a zip file parser                                      :examples:
** TODO Write a streaming unzipping csv parser                     :examples:
   This would be fairly impressive, so you could do:
   parseAsync(zipChunk(csvLine()), function(err, line) { ... }).data(....)
** TODO Change between()                                                :API:
   between(wrapper, parser[, trailing=wrapper])
   
   Meh. Not sure if I want this change.
** TODO Benchmark tests                                         :tests:speed:
   No optimization until we have some reasonable benchmarks to test
   against. The html parser should be a good starting point.
** TODO Add a streaming CSV parser example                         :examples:
** TODO Write a 'make' target that will update the docs                :docs:
   It should probably really just be part of `make release`
** TODO Make the docs prettier                                         :docs:
* active [0/10]
** TODO Error by default if there's any input remaining after parse()   :API:
   I think the main thing is that or() needs some kind of case where it
   will only replaceErrors for errors that happened internally to it. The
   current replaceErrors strategy pretty much completely clobbers errors
   flying around.
** TODO expected() and or()                                             :API:
   The way expected() works right now kinda clobbers error messages in
   annoying ways. Perhaps the right thing is to have or() accept a string
   as an optional final parser, in which case it'll use that as the
   replaced error expectation message for the entire or() clause. This
   would make things work more like Parsec's <?> combinator.
   
   Write a few tests related to error reporting before doing this,
   though. Probably as part of or().
** TODO More error reporting testing                                  :tests:
   It would be really nice to have nicer test coverage for the error
   reporting system.
** TODO throwOnError                                                    :API:
   Either get rid of this altogether (since you can just try/catch), or
   have the option return ParserState|ParseError
** TODO parseState/ParseError/etc                                   :nitpick:
   use 'parse' only for the function. Everything else should use 'parser',
   so 'parserState', 'ParserError", etc.
** TODO Write tests for examples                                      :tests:
** TODO Get tests to run on node 0.6 and 0.8 again                    :tests:
   The stream and utils stuff isn't supported, but raw mona should still pass
   those tests. Put a conditional somewhere.
** TODO Support parsing binary buffers                                  :API:
   Just define a protocol for arbitrary input streams.
** TODO Add a custom tag to JSDoc for @value                           :docs:
   To document the value returned by a successful parse.
** TODO Write an html parser and compare it                           :speed:
   http://ejohn.org/files/htmlparser.js Is a good one to test against -- it uses
   regexes, which should be fairly fast. I don't expect to be able to -beat- its
   speed, but it might be a useful point of reference.
